// use std::env;
//
// use bcrypt::{hash, verify, DEFAULT_COST};
// use jsonwebtoken::{encode, Header};
// use sqlx::{sqlite, FromRow, SqlitePool};
// const DEFAULT_SECRET_KEY: &str = "secret";
// const JWT_SECRET: String = env::var("JWT_SECRET").unwrap_or_else(|| DEFAULT_SECRET_KEY);
// #[derive(Debug, FromRow)]
// pub struct User {
//     id: String,
//     name: String,
//     email: String,
//     password: String,
//     subscription_plan: String,
//     is_banned: bool,
//     created_at: String,
//     is_admin: bool,
//     data_usage: i64,
// }
//
// impl User {
//     pub async fn create(email: &str, password: &str, pool: &SqlitePool) -> sqlx::Result<User> {
//         //     let exist_user = sqlx::query(
//         //         r#"SELECT * FROM users
//         // WHERE email = ?"#,
//         //     )
//         //     .bind(email)
//         //     .fetch_optional(pool)
//         //     .await?
//         //     .is_some();
//         //
//         //     if exist_user {
//         //         log::info!("User already exists");
//         //         return Err(sqlx::Error::RowNotFound);
//         //     }
//         //     // hash password and insert user record into database
//         //     let hashed_password = hash(password, DEFAULT_COST).unwrap();
//         //
//         //     let user_id = sqlx::query(
//         //         "INSERT INTO users (email, password,subscription_plan,
//         //                             data_usage)
//         //             VALUES (?,?,'basic','0')",
//         //     )
//         //     .bind(email.to_lowercase())
//         //     .bind(password)
//         //     .fetch_one(pool)
//         //     .await?;
//         unimplemented!()
//     }
//     pub async fn login(
//         pool: &SqlitePool,
//         email: &str,
//         password: &str,
//     ) -> Result<User, sqlx::Error> {
//         let user = sqlx::query_as::<_, User>("SELECT * FROM users WHERE email = ?")
//             .bind(email)
//             .fetch_optional(pool)
//             .await?;
//         match user {
//             Some(user) => {
//                 if verify(password, &user.password).is_ok() {
//                     return Ok(user);
//                 } else {
//                     Err(sqlx::Error::RowNotFound)
//                 }
//             }
//             _ => Err(sqlx::Error::PoolClosed),
//         }
//     }
// }
//
//
//
//

use serde::{Deserialize, Serialize};
use sqlx::{Error, FromRow, SqlitePool};

#[derive(Debug, Serialize, Deserialize, FromRow)]
pub struct User {
    id: String,
    name: String,
    email: String,
    password: String,
    subscription_plan: String,
    is_banned: bool,
    created_at: String,
    is_admin: bool,
    data_usage: i64,
}
use thiserror::Error;
#[derive(Debug, Error)]
pub enum MyError {
    #[error("Database error: {}",.0)]
    DbError(#[from] sqlx::Error),
    #[error("User Not Found")]
    UserNotFound,
}
impl User {
    pub async fn find_user_by_email(
        pool: &SqlitePool,
        email: &str,
    ) -> Result<Option<User>, MyError> {
        let user = sqlx::query_as::<_, User>("INSERT  INTO  users (email,password)  VALUES  (?,?)")
            .bind(email).bind("ueoueo".to_owned())
            .fetch_optional(pool)
            .await?;
        println!("{user:?}");
        if let Some(user) = user {
            return   Ok(Some(user));
        } else {
            return Err(MyError::UserNotFound);
        }
        Ok(user)
    }
    pub async fn update_password(pool: &SqlitePool, id: i32, password: &str) -> Result<(), Error> {
        sqlx::query(r#"UPDATE users SET password = ? WHERE id = ?"#)
            .bind(password)
            .bind(id)
            .execute(pool)
            .await?;

        Ok(())
    }
}
